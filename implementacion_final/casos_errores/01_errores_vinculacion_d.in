d
{
## inicio todo bien vinculado
^tNodo l1;
type ^tNodo tLista;
type struct {
  int val,
  tLista sig
} tNodo;
tLista l2;
proc haz(tLista l, ^tNodo & l2) {
  ^tNodo l3
  &&
  {
   type int miInt;
   miInt v
   &&
   @ l + l1 + l2 + l3;
   read l + l1 + l2 + l3;
   write l + l1 + l2 + l3;
   if l {@ l1};
   if l1 {@ l2} else {@ l3};
   while l {@ l2}
  }
};
proc p(int p) {
 int p
 &&
};
proc r(int u) {
  call r(u + 1)
}
&&
@ (l1 = (l2 + (l1 and (l2 or (l1 < l2 > l1 <= l2 >= l2 == l1 != ((l2+l1).x + - not l2) 
  + (l2 - l1 * l1^^^^ % l1 / l2)[l1+l2])))));
{
 int l
 &&
  {
   int l3
   &&
   call haz(l + l2, l3 - l2)
  }
};
## hasta aqui todo bien vinculado

## empiezan errores de vinculacion 
@ l + l3;  
@ (nd1 = (nd2 + (nd3 and (nd4 or (nd5 < nd6 > nd7 <= nd8 >= nd9 == nd10 != 
         ((nd11+nd12).x + - not nd13) 
  + (nd14 - nd15 * nd16^^^^ % nd17 / nd18)[nd19+nd20])))));
if x[l1] {@ l1[y]};
if x.x {@ (y+l1)^^^^^} else {@ z};
while x + l1 {@ l2 + y};
call noesta (l1,l2);
{
  ^entero x;
  int una;
  int dos;
  int una;
  type int dos;
  proc una (int una, int tres, ^int & tres) {
    int una;
    int tres
    &&
  }
  &&
}  
}
